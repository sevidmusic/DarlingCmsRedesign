#!/bin/bash
# dsh

set -o posix

logErrorMsg() {
    printf "\n\e[43m\e[30m%s\n\e[0m" "${1}" >> /dev/stderr
}

logErrorMsgAndExit1() {
    logErrorMsg "${1}"
    exit 1
}

determineDshDirectoryPath() {
    local CURRENT_FILE_PATH CURRENT_DIRECTORY_PATH
    CURRENT_FILE_PATH="${BASH_SOURCE[0]}"
    while [ -h "$CURRENT_FILE_PATH" ]; do # resolve $CURRENT_FILE_PATH until the file is no longer a symlink | -h is true if file exists and is a symlink
      CURRENT_DIRECTORY_PATH="$(cd -P "$(dirname "$CURRENT_FILE_PATH")" >/dev/null 2>&1 && pwd)"
      CURRENT_FILE_PATH="$(readlink "$CURRENT_FILE_PATH")"
      [[ $CURRENT_FILE_PATH != /* ]] && CURRENT_FILE_PATH="$CURRENT_DIRECTORY_PATH/$CURRENT_FILE_PATH" # if $CURRENT_FILE_PATH was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    printf "%s" "$(cd -P "$(dirname "$CURRENT_FILE_PATH")" >/dev/null 2>&1 && pwd)"
}

loadLibrary() {
    # use of -x instead of -f is intentinal, the file MUST exist and be executable
    # @seehttps://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Bash-Conditional-Expressions
    [[ ! -x "${1}" ]] && logErrorMsg "Error! Failed to load ${1}!" && logErrorMsgAndExit1 "The script either does not exist, or is not executable."
    . ${1} ${2}
}

updateAndShowManPage() {
    local users_man_directory_path users_man1_directory_path help_file_path
    users_man_directory_path="${HOME}/.local/share/man"
    users_man1_directory_path="${users_man_directory_path}/man1"
    help_file_path="$(determineDshDirectoryPath)/helpFiles/man.txt"
    [[ ! -d "${users_man_directory_path}" ]] && mkdir "${users_man_directory_path}"
    [[ ! -d "${users_man1_directory_path}" ]] && mkdir "${users_man1_directory_path}"
    [[ -d "${users_man1_directory_path}" ]] && cp "${help_file_path}" "${users_man1_directory_path}/dsh.1"
    man "${users_man1_directory_path}/dsh.1"
    exit 0
}

showHelpFile() {
    local text
    text="$(dshUI -c "$(determineDshDirectoryPath)/helpFiles/${1}" 33 "dsh -.*[>]" "[<].*[>]" "dshUnit ")"
    printf "%s" "${text}"
    exit 0
}

showHelpInfo() {
    if [[ -z "${1}" ]]; then
        updateAndShowManPage
    fi
    if [[ -z "${1}" || "${1}" == '--help' || "${1}" == '-h' ]]; then
        showHelpFile "help.txt"
    fi
    if [[ "${1}" == "FLAG" ]]; then
        showHelpFile "helpFLAG.txt"
    fi
    if [[ "${1}" == "flags" ]]; then
        showHelpFile "helpFlags.txt"
    fi
    if [[ "${1}" == "--start-development-server" ]] || [[ "${1}" == "-s" ]]; then
        showHelpFile "startDevelopmentServer.txt"
    fi
    if [[ "${1}" == "--build-app" ]] || [[ "${1}" == "-b" ]]; then
        showHelpFile "buildApp.txt"
    fi
    if [[ "${1}" == "--new" && -z "${2}" ]] || [[ "${1}" == "-n" && -z "${2}" ]]; then
        showHelpFile "new.txt"
    fi
    if [[ "${1}" == "--new" && "${2}" == "App" ]] || [[ "${1}" == "-n" && "${2}" ==  "App" ]]; then
        showHelpFile "newApp.txt"
    fi
    if [[ "${1}" == "--new" && "${2}" == "OutputComponent" ]] || [[ "${1}" == "-n" && "${2}" ==  "OutputComponent" ]]; then
        showHelpFile "newOutputComponent.txt"
    fi
    if [[ "${1}" == "--new" && "${2}" == "DynamicOutputComponent" ]] || [[ "${1}" == "-n" && "${2}" ==  "DynamicOutputComponent" ]]; then
        showHelpFile "newDynamicOutputComponent.txt"
    fi
    if [[ "${1}" == "--new" && "${2}" == "Request" ]] || [[ "${1}" == "-n" && "${2}" ==  "Request" ]]; then
        showHelpFile "newRequest.txt"
    fi
    if [[ "${1}" == "--new" && "${2}" == "Response" ]] || [[ "${1}" == "-n" && "${2}" ==  "Response" ]]; then
        showHelpFile "newResponse.txt"
    fi
    if [[ "${1}" == "--new" && "${2}" == "GlobalResponse" ]] || [[ "${1}" == "-n" && "${2}" ==  "GlobalResponse" ]]; then
        showHelpFile "newGlobalResponse.txt"
    fi
    if [[ "${1}" == "--assign-to-response" ]] || [[ "${1}" == "-a" ]]; then
        showHelpFile "assignToResponse.txt"
    fi
    if [[ "${1}" == "--php-unit" ]] || [[ "${1}" == "-p" ]]; then
        showHelpFile "phpUnit.txt"
    fi
    if [[ "${1}" == "--dsh-unit" ]] || [[ "${1}" == "-d" ]]; then
        showHelpFile "dshUnit.txt"
    fi
    logErrorMsgAndExit1 "dsh --help <FLAG> expects a valid dsh flag. Run dsh --help or man dsh for more information on how dsh works."
}


startDevelopmentServer() {
    showLoadingBar "    Starting development server at http://localhost:${1:-8080}" 'dontClear'
    /usr/bin/php -S "localhost:${1:-8080}" -t "$(determineDshDirectoryPath | sed 's/dsh//g')" &> /dev/null & xdg-open "http://localhost:${1:-8080}" &>/dev/null & disown
    exit 0
}

determineAppDirectoryPath() {
    printf "%s" "$(determineDshDirectoryPath | sed "s/dsh/Apps\/${1}/g")"
}

getAppDomainNameFromComponentsPhp() {
    grep -E "::buildDomain" "$(determineAppDirectoryPath "${1}")/Components.php" | grep -Eo "'.*'" | sed -E "s/'//g"
}

modifyAppDomain() {
    sed -i "s,$(getAppDomainNameFromComponentsPhp "${1}"),${2},g" "$(determineAppDirectoryPath "${1}")/Components.php"
}

buildApp() {
    local actual_domain
    [[ -z "${1}" ]] && logErrorMsgAndExit1 "dsh --build-app <APP_NAME> <DOMAIN> expects the name of the app be specified as the first parameter."
    [[ ! -d "$(determineAppDirectoryPath "${1}")" ]] && logErrorMsg "The specified App does not exist at $(determineAppDirectoryPath "${1}")" && notifyUser "The following Apps are available:" 0 'dontClear' && printf "\n\e[0m\e[102m\e[30m%s\e[0m\n" "$(ls Apps | sed 's/README.md//g' | column)" && logErrorMsgAndExit1 "Please specify an existing App."
    [[ ! -f "$(determineAppDirectoryPath "${1}")/Components.php" ]] && logErrorMsg "The specified App does not define a Components.php file. It cannot be built with dsh." && logErrorMsgAndExit1 "Please define a Components.php file for the App. Hint: You can always use dsh --new App <APP_NAME> <DOMAIN> to create a new app with the proper structure, and a pre-configured Components.php file. : )"
    actual_domain="$(getAppDomainNameFromComponentsPhp "${1}")"
    # Modify
    [[ -n "${2}" ]] && modifyAppDomain "${1}" "${2}"
    cd "$(determineAppDirectoryPath "${1}")"
    /usr/bin/php ./Components.php
    # Restore
    [[ -n "${2}" ]] && modifyAppDomain "${1}" "${actual_domain}"
    exit 0
}

validateMode() {
    [[ -z "${1}" ]] && logErrorMsgAndExit1 "dsh --new <MODE> <ARGUMENTS>... expects a mode be specified as the first parameter."
    declare -a validModes=( App OutputComponent DynamicOutputComponent Request Response GlobalResponse)
    declare -A map
    for key in "${!validModes[@]}"; do map[${validModes[$key]}]="$key"; done
    [[ -z "${map[${1}]}" ]] && logErrorMsg "dsh --new expects a valid mode. The following modes are available:" && logErrorMsg "$(printf '\n\e[0m\e[104m\e[30m%s\e[0m\n' "${validModes[@]}" | column)" && logErrorMsg "For more information about the dsh --new flag, use dsh --help --new" && logErrorMsgAndExit1 "For more information about a specific mode, use dsh --help --new <MODE>"
}

createNewApp() {
      [[ -z "${1}" ]] && logErrorMsg "dsh --new App <APP_NAME> <DOMAIN> expects the new App's name be specified as the first modal argument." && logErrorMsg "For example, to create an app named Foo:" && logErrorMsg "dsh --new App Foo" && logErrorMsgAndExit1 "For more information use dsh --help --new App"
      [[ -d "$(determineAppDirectoryPath "${1}")" ]] && logErrorMsgAndExit1 "An App named ${1} already exists, please specify a unique name for the new App."
      showLoadingBar "Preparing to create the new ${1} app at $(determineAppDirectoryPath "${1}")" 'dontClear'
      showLoadingBar "    Creating App directory at $(determineAppDirectoryPath "${1}")" 'dontClear'
      mkdir "$(determineAppDirectoryPath "${1}")"

      showLoadingBar "    Creating App's OutputComponents directory at $(determineAppDirectoryPath "${1}")/OutputComponents" 'dontClear'
      mkdir "$(determineAppDirectoryPath "${1}")/OutputComponents"

      showLoadingBar "    Creating App's Requests directory at $(determineAppDirectoryPath "${1}")/Requests" 'dontClear'
      mkdir "$(determineAppDirectoryPath "${1}")/Requests"

      showLoadingBar "    Creating App's Responses directory at $(determineAppDirectoryPath "${1}")/Responses" 'dontClear'
      mkdir "$(determineAppDirectoryPath "${1}")/Responses"

      showLoadingBar "    Creating App's DynamicOutput directory at $(determineAppDirectoryPath "${1}")/DynamicOutput" 'dontClear'
      mkdir "$(determineAppDirectoryPath "${1}")/DynamicOutput"

      showLoadingBar "    Creating App's css directory at $(determineAppDirectoryPath "${1}")/css" 'dontClear'
      mkdir "$(determineAppDirectoryPath "${1}")/css"

      showLoadingBar "    Creating App's js directory at $(determineAppDirectoryPath "${1}")/js" 'dontClear'
      mkdir "$(determineAppDirectoryPath "${1}")/js"

      showLoadingBar "    Creating App's Components.php file at $(determineAppDirectoryPath "${1}")/Components.php" 'dontClear'
      cp "$(determineDshDirectoryPath)/FileTemplates/Components.php" "$(determineAppDirectoryPath "${1}")/Components.php"

      notifyUser "The ${1} App was created successfully." 0 'dontClear'
      exit 0
}

createNewOutputComponent() {
    [[ -z "${1}" ]] && logErrorMsgAndExit1 "You must specify a name to assign to the new OutputComponent"
    exit 0
}

loadLibrary "$(determineDshDirectoryPath | sed 's/\/dsh//g')/dshUI/dshUI" "--theme dsh.sh"

while test $# -gt 0; do
  case "${1}" in
  -h | --help)
    shift
    showHelpInfo "${1}" "${2}"
    ;;
  -s | --start-development-server)
    shift
    startDevelopmentServer "${1:-8080}"
    ;;
  -b | --build-app)
    shift
    buildApp "${1}" "${2}"
    ;;
  -n | --new)
    shift
    validateMode "${1}"
    case "${1}" in
    App)
      shift
      createNewApp "${1}" "${2}"
      ;;
    OutputComponent)
      shift
      createNewOutputComponent
      ;;
    esac
    ;;
  *)
    shift
    logErrorMsgAndExit1 "Invalid flag ${1}"
    ;;
  esac
done

notifyUser "dsh is still under development. It is not ready for use." 0 'dontClear'
