### About

**dsh** is a command line utility designed to aide in development with the
[Darling Data Management System](https://github.com/sevidmusic/DarlingDataManagementSystem).

**dsh** can perform various tasks, from running tests, to building apps and starting
a development server.


Below is an overview of the flags available to **dsh**:

`dsh --help | -h` : Show the standard man page for **dsh**. This is the same as running
`man dsh`


`dsh --help | -h <FLAG>` : Detailed help information about the specified flag.
For example, `dsh -h --build-app` would show detailed help information about the
`--build-app` flag.


`dsh --help flags` : Show brief help information about all available flags.


`dsh --start-development-server | -s <PORT>` : Start a development server at
`http://localhost:<PORT>`. If `<PORT>` is not specified start a development
server at `http://localhost:8080`.


`dsh --build-app | -b <APP_NAME> <DOMAIN>` : Build an App for a
specified `<DOMAIN>` by running `php Apps/<APP_NAME>/Components.php`.
If `<DOMAIN>` is not specified then the domain defined in the App's
`Components.php` file will be used. If the specified App was already built for the
specified `<DOMAIN>`, then the App will not be built, an error will be logged,
and **dsh** will exit.


`dsh --new | -n <MODE> <...ARGUMENTS>` : The **new** flag is used to create. The
**new** flag is _modal_, meaning the specified `<MODE>` determines what is created.
Different _modes_ expect different `<...ARGUMENTS>`, and different _modes_ may
expect different numbers of `<...ARGUMENTS>`.

The following _modes_ are available:

`dsh --new App <APP_NAME> <DOMAIN>` : Create a new App at `Apps/<APP_NAME>/`
The domain assigned to the new App will be `<DOMAIN>` if specified, or
`http://localhost:8080` by default.
The following will be created for the new App:
- A directory for the App at `Apps/<APP_NAME>`
- A Components.php configuration file for the App at `Apps/<APP_NAME>/Components.php`
      This generated Components.php file will look as follows, with `<DOMAIN>`
      replaced either by the specified `<DOMAIN>` or `http:/localhost:8080`
      if `<DOMAIN>` was not specified:
```
<?php
/** <APP_NAME> | Components.php *>

use DarlingDataManagementSystem\classes\component\Factory\App\AppComponentsFactory;

ini_set('display_errors', true);

require(
    '..' .
    DIRECTORY_SEPARATOR .
    '..' .
    DIRECTORY_SEPARATOR .
    'vendor' .
    DIRECTORY_SEPARATOR .
    'autoload.php'
);

function loadComponentConfigFiles(string $configurationDirectoryName, AppComponentsFactory $appComponentsFactory): void {
    $configurationDirectoryPath = __DIR__ . DIRECTORY_SEPARATOR . $configurationDirectoryName . DIRECTORY_SEPARATOR;
    foreach(array_diff(scandir($configurationDirectoryPath), array('.', '..')) as $file) {
        require $configurationDirectoryPath . $file;
    }
}

$appComponentsFactory = new AppComponentsFactory(
    ...AppComponentsFactory::buildConstructorArgs(
    AppComponentsFactory::buildDomain('<DOMAIN>')
    )
);

loadComponentConfigFiles('OutputComponents', $appComponentsFactory);
loadComponentConfigFiles('Requests', $appComponentsFactory);
loadComponentConfigFiles('Responses', $appComponentsFactory);

$appComponentsFactory->buildLog(AppComponentsFactory::SHOW_LOG | AppComponentsFactory::SAVE_LOG);

```
- A directory for all of the App's Output component configuration files at `Apps/<APP_NAME>/OutputComponents/`
- A directory for all of the App's Request component configuration files at `Apps/<APP_NAME>/Requests/`
- A directory for all of the App's Response component configuration files at `Apps/<APP_NAME>/Responses/`
- A directory for the App's unique Dynamic Output files at `Apps/DynamicOutput/`
- A directory for the App's css at `Apps/<APP_NAME>/css/`
- A directory for the App's js files `Apps/<APP_NAME>/js`


`dsh --new OutputComponent <APP_NAME> <OUTPUT_COMPONENT_NAME> <OUTPUT_COMPONENT_CONTAINER> <OUTPUT_COMPONENT_POSITION> <OUTPUT>`
Creates a new OutputComponent configuration file at
`Apps/<APP_NAME>/OutputComponents/<OUTPUT_COMPONENT_NAME>.php` with the following
structure:
```
<?php
/** <APP_NAME> | <OUTPUT_COMPONENT_NAME>.php */

$appComponentsFactory->buildOutputComponent(
    '<OUTPUT_COMPONENT_NAME>',
    '<OUTPUT_COMPONENT_CONTAINER>',
    '<OUTPUT>'
    <OUTPUT_COMPONENT_POSITION>
);

```
For example:
```
dsh --new OutputComponent Foo Bar Output 0 "Baz"
```
Would create the following configuration file at `Apps/Foo/OutputComponents/Bar.php`
```
<?php
/** Foo | Bar.php */

$appComponentsFactory->buildOutputComponent(
    'Bar',
    'Output',
    'Baz'
    0
);

```


`dsh --new DynamicOutputComponent <APP_NAME> <DYNAMIC_OUTPUT_COMPONENT_NAME> <DYNAMIC_OUTPUT_COMPONENT_CONTAINER> <DYNAMIC_OUTPUT_COMPONENT_POSITION> <DYNAMIC_OUTPUT_FILE_NAME>`
Creates a new DynamicOutputComponent configuration file at `Apps/<APP_NAME>/OutputComponents/<DYNAMIC_OUTPUT_COMPONENT_NAME>.php`
with the following structure:
```
<?php
/** <APP_NAME> | <DYNAMIC_OUTPUT_COMPONENT_NAME>.php */

$appComponentsFactory->buildDynamicOutputComponent(
    '<DYNAMIC_OUTPUT_COMPONENT_NAME>',
    '<DYNAMIC_OUTPUT_COMPONENT_CONTAINER>',
    <DYNAMIC_OUTPUT_COMPONENT_POSITION>,
    '<APP_NAME>',
    '<DYNAMIC_OUTPUT_FILE_NAME>'
);

```


For example:
```
dsh --new DynamicOutput Foo Baz Output 0.4 BazDynamicOutputFile.php
```
Would create the following DynamicOutputComponent configuration file at `Apps/Foo/OutputComponents/Baz.php`
```
<?php
/** Foo | Baz.php */

$appComponentsFactory->buildDynamicOutputComponent(
    'Baz',
    'Output',
    0.4,
    'Foo',
    'BazDynamicOutputFile.php'
);
```


`dsh --new Request <APP_NAME> <REQUEST_NAME> <REQUEST_CONTAINER> <RELATIVE_URL>`
Creates a new Request configuration file at `Apps/<APP_NAME>/Requests/<REQUEST_NAME>.php`
with the following structure:
```
<?php
/** <APP_NAME> | <REQUEST_NAME>.php */

$appComponentsFactory->buildRequest(
    '<REQUEST_NAME>',
    '<REQUEST_CONTAINER>',
    $appComponentsFactory->getApp()->getAppDomain()->getUrl() . '/<RELATIVE_URL>',
);

```

```
dsh --new Request Foo Bar Requests index.php
```
Would create the following Request configuration file at `Apps/Foo/Requests/Bar.php`
```
<?php
/** Foo | Bar.php */

$appComponentsFactory->buildRequest(
    'Bar',
    'Requests',
    $appComponentsFactory->getApp()->getAppDomain()->getUrl() . '/index.php',
);

```


`dsh --new Response <APP_NAME> <RESPONSE_NAME> <RESPONSE_POSITION>`
Create a new Response at `Apps/<APP_NAME>/Responses/<RESPONSE_NAME>.php`
witht the following structure:
```
<?php
/** <APP_NAME> | <RESPONSE_NAME>.php */

use DarlingDataManagementSystem\classes\component\OutputComponent;
use DarlingDataManagementSystem\classes\component\DynamicOutputComponent;
use DarlingDataManagementSystem\classes\component\Web\Routing\Request;

$appComponentsFactory->buildResponse(
    '<RESPONSE_NAME>',
    <RESPONSE_POSITION>,
);

```
For example:
`dsh --new Response Foo BarResponse 2`
Would create the following configuration file at `Apps/Foo/Responses/BarResponse.php`:
```
<?php
/** Foo | BarResponse.php */

use DarlingDataManagementSystem\classes\component\OutputComponent;
use DarlingDataManagementSystem\classes\component\DynamicOutputComponent;
use DarlingDataManagementSystem\classes\component\Web\Routing\Request;

$appComponentsFactory->buildResponse(
    'BarResponse',
    2,
);

```
Note: This new Response will not be assigned any OutputComponents or requests,
such assignments will need to be made after the new Response is created via
`dsh --assign-to-response <APP_NAME> <COMPONENT_NAME> <COMPONENT_TYPE> <COMPONENT_CONTAINER> <RESPONSE_NAME>`
For example to create a new Response named BarResponse for the Foo app with 1 new
OutputComponent and 1 new Request assigned:
```
dsh --new OutputComponent Foo BarOutput Output 0 "Baz"
dsh --new Request Foo BarRequest Requests index.php
dsh --new Response Foo BarResponse 0
dsh --assign-to-response Foo BarOutput OutputComponent Output BarResponse
dsh --assign-to-response Foo BarRequest Request Requests BarResponse
```
Would create the following Response configuration file at `Apps/Foo/Responses/BarResponse.php`:
```
<?php
/** Foo | BarResponse.php */

use DarlingDataManagementSystem\classes\component\OutputComponent;
use DarlingDataManagementSystem\classes\component\DynamicOutputComponent;
use DarlingDataManagementSystem\classes\component\Web\Routing\Request;

$appComponentsFactory->buildResponse(
    'BarResponse',
    0,
    $appComponentsFactory->getComponentCrud()->readByNameAndType(
        'BarRequest',
        Request::class,
        $appComponentsFactory->getLocation(),
        'Requests'
    ),
    $appComponentsFactory->getComponentCrud()->readByNameAndType(
        'BarOutput',
        OutputComponent::class,
        $appComponentsFactory->getLocation(),
        'Output'
    ),
);

```


`dsh --new GlobalResponse <APP_NAME> <GLOBAL_RESPONSE_NAME> <GLOBAL_RESPONSE_POSITION>`
Create a new GlobalResponse at `Apps/<APP_NAME>/Responses/<GLOBAL_RESPONSE_NAME>.php`
with the following structure:
```
<?php
/** <APP_NAME> | <GLOBAL_RESPONSE_NAME>.php */

use DarlingDataManagementSystem\classes\component\OutputComponent;
use DarlingDataManagementSystem\classes\component\DynamicOutputComponent;

$appComponentsFactory->buildGlobalResponse(
    '<GLOBAL_RESPONSE_NAME>',
    <GLOBAL_RESPONSE_POSITION>,
);

```
Note: This new GlobalResponse will not be assigned any OutputComponents.
OutputComponents will need to be assigned after the new GlobalResponse is created via `dsh --assign-to-response <APP_NAME> <COMPONENT_NAME> <COMPONENT_TYPE> <COMPONENT_CONTAINER> <RESPONSE_NAME>`
For example to create a new GlobalResponse named BarGlobalResponse for the
Foo app with 1 new OutputComponent assigned:
```
dsh --new GlobalResponse Foo BarGlobalResponse 0
dsh --new DynamicOutputComponent Foo BarDynamicOutput Output 0 "Baz.html"
dsh --assign-to-response Foo BarDynamicOutput DynamicOutputComponent Output BarGlobalResponse
```
Would create the following GlobalResponse configuration file at
`Apps/Foo/GlobalResponses/BarGlobalResponse.php`:

```
<?php
/** Foo | BarGlobalResponse.php */

use DarlingDataManagementSystem\classes\component\OutputComponent;
use DarlingDataManagementSystem\classes\component\DynamicOutputComponent;

$appComponentsFactory->buildGlobalResponse(
    'BarGlobalResponse',
    1,
    $appComponentsFactory->getComponentCrud()->readByNameAndType(
        'BarDynamicOutput',
        DynamicOutputComponent::class,
        $appComponentsFactory->getLocation(),
        'Output'
    ),
);

```


`dsh --assign-to-response <APP_NAME> <COMPONENT_NAME> <COMPONENT_TYPE> <COMPONENT_CONTAINER> <RESPONSE_NAME>`
Assign the component defined for the `<APP_NAME>` app whose name is `<COMPONENT_NAME>` and type is `<COMPONENT_TYPE>`
to the response defined for the `<APP_NAME>` app whose name is `<RESPONSE_NAME>`.
This will add code structured as follows to the specified Respone's definition:
```
    $appComponentsFactory->getComponentCrud()->readByNameAndType(
        '<COMPONENT_NAME>',
        <COMPONENT_TYPE>::class,
        $appComponentsFactory->getLocation(),
        '<COMPONENT_CONTAINER>'
    ),
```
For example, assuming **BarResponse** is defined for the Foo app, and is not already assigned any components,
and that **BarRequest** is also defined for the Foo app:
`dsh --assign-to-response Foo BarRequest Request Requests BarResponse`
Would result in the following Response configuration file at `Apps/Foo/Responses/BarResponse.php`:
```
<?php
/** Foo | BarResponse.php */

use DarlingDataManagementSystem\classes\component\OutputComponent;
use DarlingDataManagementSystem\classes\component\DynamicOutputComponent;
use DarlingDataManagementSystem\classes\component\Web\Routing\Request;

$appComponentsFactory->buildResponse(
    'BarResponse',
    0,
    $appComponentsFactory->getComponentCrud()->readByNameAndType(
        'BarRequest',
        Request::class,
        $appComponentsFactory->getLocation(),
        'Requests'
    ),
);

```

`dsh --php-unit <PHP_UNIT_CONFIG_FILE_PATH>` Run PhpUnit tests. If `<PHP_UNIT_CONFIG_FILE_PATH>`
is specified it will be used, otherwise the Darling Data Management System's `php.xml`
file will be used.

`dsh --dsh-unit <DSH_UNIT_CONFIG_FILE_PATH> <TEST_GROUP_NAME>` Run dshUnit tests.
If `<DSH_UNIT_CONFIG_FILE_PATH>` is specified it will be used, otherwise dshUnit's
`dshUnitConfig.sh` file will be used. If `<TEST_GROUP_NAME>` is specified, then the
specified test group will be run, otherwise the `all` test group will be run.

### Notes:
Idea: As an unexpected consequence of the design of the DDMS and dsh, entire apps
can be defined with a single bash scripts calling **dsh** commands.
For example the following would create an app named **Foo** with one OutuputComponent,
on Request, and one Response:
```
#!/bin/bash
# createFooApp.sh
set -o posix

dsh -n app Foo
dsh -n OutputComponent Foo BarOutput Output 0 "Baz"
dsh -n Request Foo BarRequest Requests http://localhost:8080
dsh -n Response Foo BarResponse 1
dsh --assign-to-response Foo BarOutput OutputComponent Output BarResponse
dsh --assign-to-response Foo BarRequest Request Requests BarResponse
```

Expanding on the idea above, a single bash script could configure
multiple apps for the same domain.

```
#!/bin/bash
# createMultipleApps.sh
set -o posix

dsh -n app Foo
dsh -n OutputComponent Foo BarOutput Output 0 "Baz"
dsh -n Request Foo BarRequest Requests http://localhost:8080
dsh -n Response Foo BarResponse 1
dsh --assign-to-response Foo BarOutput OutputComponent Output BarResponse
dsh --assign-to-response Foo BarRequest Request Requests BarResponse

dsh -n app Bazzer
dsh -n OutputComponent Bazzer BarOutput Output 0 "Baz"
dsh -n Request Bazzer BarRequest Requests http://localhost:8080
dsh -n Response Bazzer BarResponse 1
dsh --assign-to-response Bazzer BarOutput OutputComponent Output BarResponse
dsh --assign-to-response Bazzer BarRequest Request Requests BarResponse

dsh -n app Bar
dsh -n OutputComponent Bar BarOutput Output 0 "Baz"
dsh -n Request Bar BarRequest Requests http://localhost:8080
dsh -n Response Bar BarResponse 1
dsh --assign-to-response Bar BarOutput OutputComponent Output BarResponse
dsh --assign-to-response Bar BarRequest Request Requests BarResponse

```

A more tangible example:

A simple website could be created  using a single bash script that defines 2 apps
to create a single page site with an HTML 5 Music player and a static news feed.

```
#!/bin/bash

set -o posix

dsh -n app MusicPlayer
dsh -n OutputComponent MusicPlayer MusicPlayerOutput Output 0 "<audio controls><source src="track1.ogg" type="audio/ogg"><source src="track2.mp3" type="audio/mpeg">Your browser does not support the audio element.</audio>"
dsh -n Request MusicPlayer MusicPlayerRequest Requests http://some.music.site/
dsh -n Response MusicPlayer MusicPlayerResponse 1
dsh --assign-to-response MusicPlayer MusicPlayerOutput OutputComponent Output MusicPlayerResponse
dsh --assign-to-response MusicPlayer MusicPlayerRequest Request Requests MusicPlayerResponse

dsh -n app NewsFeed
dsh -n OutputComponent NewsFeed NewsFeedOutput Output 0 "<h1>Upcoming Events:</h1><h3>Next Friday @ 9:00 pm</h3><p>Live at the Bar</p><h1>Upcoming Events:</h1><h3>Next Saturday @ 3:00 pm</h3><p>Live at the Bar</p><h1>Upcoming Events:</h1><h3>Next Sunday @ 7:00 pm</h3><p>Live at the Park</p>"
dsh -n Request NewsFeed NewsFeedRequest Requests http://some.music.site/
dsh -n Response NewsFeed NewsFeedResponse 1
dsh --assign-to-response NewsFeed NewsFeedOutput OutputComponent Output NewsFeedResponse
dsh --assign-to-response NewsFeed NewsFeedRequest Request Requests NewsFeedResponse

```

To build all the apps defined in the example above:

```
dsh -b MusicPlayer
dsh -b NewsFeed

```
@todo Summary:

Implement `dsh --help | -h`
Implement `dsh --help | -h <FLAG>`
Implement `dsh --help flags`
Implement `dsh --start-development-server | -s <PORT>`
Implement `dsh --build-app | -b <APP_NAME> <DOMAIN>`
Implement `dsh --new | -n <MODE> <...ARGUMENTS>`
Implement `dsh --new App <APP_NAME> <DOMAIN>`
Implement `dsh --new OutputComponent <APP_NAME> <OUTPUT_COMPONENT_NAME> <OUTPUT_COMPONENT_CONTAINER> <OUTPUT_COMPONENT_POSITION> <OUTPUT>`
Implement `dsh --new DynamicOutputComponent <APP_NAME> <DYNAMIC_OUTPUT_COMPONENT_NAME> <DYNAMIC_OUTPUT_COMPONENT_CONTAINER> <DYNAMIC_OUTPUT_COMPONENT_POSITION> <DYNAMIC_OUTPUT_FILE_NAME>`
Implement `dsh --new Request <APP_NAME> <REQUEST_NAME> <REQUEST_CONTAINER> <RELATIVE_URL>`
Implement `dsh --new Response <APP_NAME> <RESPONSE_NAME> <RESPONSE_POSITION>`
Implement `dsh --new GlobalResponse <APP_NAME> <GLOBAL_RESPONSE_NAME> <GLOBAL_RESPONSE_POSITION>`
Implement `dsh --assign-to-response <APP_NAME> <COMPONENT_NAME> <COMPONENT_TYPE> <COMPONENT_CONTAINER> <RESPONSE_NAME>`
Implement `dsh --php-unit <PHP_UNIT_CONFIG_FILE_PATH>` Run PhpUnit tests. If `<PHP_UNIT_CONFIG_FILE_PATH>`
Implement `dsh --dsh-unit <DSH_UNIT_CONFIG_FILE_PATH> <TEST_GROUP_NAME>` Run dshUnit tests.

@todo Details

1. Implement `dsh --help | -h`
`dsh --help | -h` All help info is defined in appropriate dsh help files at `dsh/dshHelp/<HELP_FILE_NAME>.txt`
The output of `dsh --help` must match the output of `man dsh` and vice versa.
If a man page file does not exist at `/usr/local/man/man1/dsh.1` when `dsh --help` is run, then `dsh --help` MUST
create it.

Tests:
```
testDshHelpRunsWithoutError()
testDshHelpCreatesSystemManPageForDsh()
testDshHelpOutputMatchesManDshOutput()

```
2. Implement `dsh --help | -h <FLAG>`
`dsh --help <FLAG>` will output the content of the appropriate dsh help file. All flags MUST have a corresponding help file defined for them at `dsh/dshHelp/<HELP_FILE_NAME>.txt`.
For example the `--build-app` flag would have it's help info defined in `dsh/dshHelp/buildApp.txt`
_Note: Help files SHOULD be assigned camel case names._
```
testDshHelpFLAGRunsWithoutError()
testDshHelpFLAGOutputMatchesAppropriateDshHelpFileContent()
```
3. Implement `dsh --help flags`
`dsh --help flags` will output the content of the `dsh/dshHelp/flags.txt` help file.
```
testDshHelpFlagsRunsWithoutError"
testDshHelpFlagsOutputMatchesFlagsHelpFileContent()
```
4. Implement `dsh --start-development-server | -s <PORT>`
5. Implement `dsh --build-app | -b <APP_NAME> <DOMAIN>`
6. Implement `dsh --new | -n <MODE> <...ARGUMENTS>`
7. Implement `dsh --new App <APP_NAME> <DOMAIN>`
8. Implement `dsh --new OutputComponent <APP_NAME> <OUTPUT_COMPONENT_NAME> <OUTPUT_COMPONENT_CONTAINER> <OUTPUT_COMPONENT_POSITION> <OUTPUT>`
9. Implement `dsh --new DynamicOutputComponent <APP_NAME> <DYNAMIC_OUTPUT_COMPONENT_NAME> <DYNAMIC_OUTPUT_COMPONENT_CONTAINER> <DYNAMIC_OUTPUT_COMPONENT_POSITION> <DYNAMIC_OUTPUT_FILE_NAME>`
10. Implement `dsh --new Request <APP_NAME> <REQUEST_NAME> <REQUEST_CONTAINER> <RELATIVE_URL>`
11. Implement `dsh --new Response <APP_NAME> <RESPONSE_NAME> <RESPONSE_POSITION>`
12. Implement `dsh --new GlobalResponse <APP_NAME> <GLOBAL_RESPONSE_NAME> <GLOBAL_RESPONSE_POSITION>`
13. Implement `dsh --assign-to-response <APP_NAME> <COMPONENT_NAME> <COMPONENT_TYPE> <COMPONENT_CONTAINER> <RESPONSE_NAME>`
14. Implement `dsh --php-unit <PHP_UNIT_CONFIG_FILE_PATH>` Run PhpUnit tests. If `<PHP_UNIT_CONFIG_FILE_PATH>`
15. Implement `dsh --dsh-unit <DSH_UNIT_CONFIG_FILE_PATH> <TEST_GROUP_NAME>` Run dshUnit tests.

