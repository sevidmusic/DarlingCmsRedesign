#!/bin/bash

set -o posix

demoTheme() {
    clear
    printf "\n%sNORMAL_TEXT" "${NORMAL_TEXT}"
    printf "\n%sBOLD_TEXT" "${BOLD_TEXT}"
    printf "\n%sUNDERLINED_TEXT" "${UNDERLINED_TEXT}"
    printf "\n%sBLINKING_TEXT" "${BLINKING_TEXT}"
    printf "\n%sREVERSE_TEXT" "${REVERSE_TEXT}"

    printf "\n%sNORMAL_COLOR_1" "${NORMAL_COLOR_1}"
    printf "\n%sNORMAL_COLOR_2" "${NORMAL_COLOR_2}"
    printf "\n%sNORMAL_COLOR_3" "${NORMAL_COLOR_3}"
    printf "\n%sNORMAL_COLOR_4" "${NORMAL_COLOR_4}"
    printf "\n%sNORMAL_COLOR_5" "${NORMAL_COLOR_5}"
    printf "\n%sNORMAL_COLOR_6" "${NORMAL_COLOR_6}"
    printf "\n%sNORMAL_COLOR_7" "${NORMAL_COLOR_7}"
    printf "\n%sNORMAL_COLOR_8" "${NORMAL_COLOR_8}"
    printf "\n%sNORMAL_COLOR_9" "${NORMAL_COLOR_9}"
    printf "\n%sNORMAL_COLOR_10" "${NORMAL_COLOR_10}"
    printf "\n%sNORMAL_COLOR_11" "${NORMAL_COLOR_12}"
    printf "\n%sNORMAL_COLOR_12" "${NORMAL_COLOR_12}"
    printf "\n%sNORMAL_COLOR_13" "${NORMAL_COLOR_13}"
    printf "\n%sNORMAL_COLOR_14" "${NORMAL_COLOR_14}"
    printf "\n%sNORMAL_COLOR_15" "${NORMAL_COLOR_15}"
    printf "\n%sNORMAL_COLOR_16" "${NORMAL_COLOR_16}"

    printf "\n%sBOLD_COLOR_1" "${BOLD_COLOR_1}"
    printf "\n%sBOLD_COLOR_2" "${BOLD_COLOR_2}"
    printf "\n%sBOLD_COLOR_3" "${BOLD_COLOR_3}"
    printf "\n%sBOLD_COLOR_4" "${BOLD_COLOR_4}"
    printf "\n%sBOLD_COLOR_5" "${BOLD_COLOR_5}"
    printf "\n%sBOLD_COLOR_6" "${BOLD_COLOR_6}"
    printf "\n%sBOLD_COLOR_7" "${BOLD_COLOR_7}"
    printf "\n%sBOLD_COLOR_8" "${BOLD_COLOR_8}"
    printf "\n%sBOLD_COLOR_9" "${BOLD_COLOR_9}"
    printf "\n%sBOLD_COLOR_10" "${BOLD_COLOR_10}"
    printf "\n%sBOLD_COLOR_11" "${BOLD_COLOR_12}"
    printf "\n%sBOLD_COLOR_12" "${BOLD_COLOR_12}"
    printf "\n%sBOLD_COLOR_13" "${BOLD_COLOR_13}"
    printf "\n%sBOLD_COLOR_14" "${BOLD_COLOR_14}"
    printf "\n%sBOLD_COLOR_15" "${BOLD_COLOR_15}"
    printf "\n%sBOLD_COLOR_16" "${BOLD_COLOR_16}"

    printf "\n%sUNDERLINED_COLOR_1" "${UNDERLINED_COLOR_1}"
    printf "\n%sUNDERLINED_COLOR_2" "${UNDERLINED_COLOR_2}"
    printf "\n%sUNDERLINED_COLOR_3" "${UNDERLINED_COLOR_3}"
    printf "\n%sUNDERLINED_COLOR_4" "${UNDERLINED_COLOR_4}"
    printf "\n%sUNDERLINED_COLOR_5" "${UNDERLINED_COLOR_5}"
    printf "\n%sUNDERLINED_COLOR_6" "${UNDERLINED_COLOR_6}"
    printf "\n%sUNDERLINED_COLOR_7" "${UNDERLINED_COLOR_7}"
    printf "\n%sUNDERLINED_COLOR_8" "${UNDERLINED_COLOR_8}"
    printf "\n%sUNDERLINED_COLOR_9" "${UNDERLINED_COLOR_9}"
    printf "\n%sUNDERLINED_COLOR_10" "${UNDERLINED_COLOR_10}"
    printf "\n%sUNDERLINED_COLOR_11" "${UNDERLINED_COLOR_12}"
    printf "\n%sUNDERLINED_COLOR_12" "${UNDERLINED_COLOR_12}"
    printf "\n%sUNDERLINED_COLOR_13" "${UNDERLINED_COLOR_13}"
    printf "\n%sUNDERLINED_COLOR_14" "${UNDERLINED_COLOR_14}"
    printf "\n%sUNDERLINED_COLOR_15" "${UNDERLINED_COLOR_15}"
    printf "\n%sUNDERLINED_COLOR_16" "${UNDERLINED_COLOR_16}"

    printf "\n%sBLINKING_COLOR_1" "${BLINKING_COLOR_1}"
    printf "\n%sBLINKING_COLOR_2" "${BLINKING_COLOR_2}"
    printf "\n%sBLINKING_COLOR_3" "${BLINKING_COLOR_3}"
    printf "\n%sBLINKING_COLOR_4" "${BLINKING_COLOR_4}"
    printf "\n%sBLINKING_COLOR_5" "${BLINKING_COLOR_5}"
    printf "\n%sBLINKING_COLOR_6" "${BLINKING_COLOR_6}"
    printf "\n%sBLINKING_COLOR_7" "${BLINKING_COLOR_7}"
    printf "\n%sBLINKING_COLOR_8" "${BLINKING_COLOR_8}"
    printf "\n%sBLINKING_COLOR_9" "${BLINKING_COLOR_9}"
    printf "\n%sBLINKING_COLOR_10" "${BLINKING_COLOR_10}"
    printf "\n%sBLINKING_COLOR_11" "${BLINKING_COLOR_12}"
    printf "\n%sBLINKING_COLOR_12" "${BLINKING_COLOR_12}"
    printf "\n%sBLINKING_COLOR_13" "${BLINKING_COLOR_13}"
    printf "\n%sBLINKING_COLOR_14" "${BLINKING_COLOR_14}"
    printf "\n%sBLINKING_COLOR_15" "${BLINKING_COLOR_15}"
    printf "\n%sBLINKING_COLOR_16" "${BLINKING_COLOR_16}"

    printf "\n%sREVERSE_COLOR_1" "${REVERSE_COLOR_1}"
    printf "\n%sREVERSE_COLOR_2" "${REVERSE_COLOR_2}"
    printf "\n%sREVERSE_COLOR_3" "${REVERSE_COLOR_3}"
    printf "\n%sREVERSE_COLOR_4" "${REVERSE_COLOR_4}"
    printf "\n%sREVERSE_COLOR_5" "${REVERSE_COLOR_5}"
    printf "\n%sREVERSE_COLOR_6" "${REVERSE_COLOR_6}"
    printf "\n%sREVERSE_COLOR_7" "${REVERSE_COLOR_7}"
    printf "\n%sREVERSE_COLOR_8" "${REVERSE_COLOR_8}"
    printf "\n%sREVERSE_COLOR_9" "${REVERSE_COLOR_9}"
    printf "\n%sREVERSE_COLOR_10" "${REVERSE_COLOR_10}"
    printf "\n%sREVERSE_COLOR_11" "${REVERSE_COLOR_12}"
    printf "\n%sREVERSE_COLOR_12" "${REVERSE_COLOR_12}"
    printf "\n%sREVERSE_COLOR_13" "${REVERSE_COLOR_13}"
    printf "\n%sREVERSE_COLOR_14" "${REVERSE_COLOR_14}"
    printf "\n%sREVERSE_COLOR_15" "${REVERSE_COLOR_15}"
    printf "\n%sREVERSE_COLOR_16" "${REVERSE_COLOR_16}"


    printf "${NORMAL_TEXT}"
    printf "${NORMAL_TEXT}"
    printf "${NORMAL_TEXT}"
    printf "${NORMAL_TEXT}"
    printf "${NORMAL_TEXT}"
}

setTextStyleCode() {
  printf "\e[%sm" "${1}"
}

logErrorMsg() {
    printf "\n%s%s\n%s" "$(setTextStyleCode 33)" "${1}" "$(setTextStyleCode 0)" >> /dev/stderr
}

logErrorMsgAndExit1() {
    logErrorMsg "${1}"
    exit 1
}

determineCurrentDirectoryPath() {
    local CURRENT_FILE_PATH CURRENT_DIRECTORY_PATH
    CURRENT_FILE_PATH="${BASH_SOURCE[0]}"
    while [ -h "$CURRENT_FILE_PATH" ]; do # resolve $CURRENT_FILE_PATH until the file is no longer a symlink | -h is true if file exists and is a symlink
      CURRENT_DIRECTORY_PATH="$(cd -P "$(dirname "$CURRENT_FILE_PATH")" >/dev/null 2>&1 && pwd)"
      CURRENT_FILE_PATH="$(readlink "$CURRENT_FILE_PATH")"
      [[ $CURRENT_FILE_PATH != /* ]] && CURRENT_FILE_PATH="$CURRENT_DIRECTORY_PATH/$CURRENT_FILE_PATH" # if $CURRENT_FILE_PATH was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    printf "%s" "$(cd -P "$(dirname "$CURRENT_FILE_PATH")" >/dev/null 2>&1 && pwd)"
}

loadLibrary() {
    # use of -x instead of -f is intentinal, the file MUST exist and be executable
    # @seehttps://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Bash-Conditional-Expressions
    [[ ! -x "${1}" ]] && logErrorMsg "Error! Failed to load ${1}!" && logErrorMsgAndExit1 "The script either does not exist, or is not executable."
    . "${1}"
}

logInvalidFlagErrorAndExit1() {
    logErrorMsg "Invalid flag ${1}"
    logErrorMsgAndExit1 "dshUI accepts one flag, --theme, or -t for short. The --theme flag is used to specify an alternative theme file."
}

logMissingFlagArgumentErrorAndExit1() {
    logErrorMsgAndExit1 "You must specify the ${1} when using the ${2} flag"
}

logFileDoesNotExistErrorAndExit1() {
    logErrorMsgAndExit1 "The ${1} file either does not exist, or is not executable."
}

determineThemeFilePath() {
    printf "%s" "$(determineCurrentDirectoryPath)/dshUIThemes/${1}"
}

while test $# -gt 0; do
  case "$1" in
  -h | --help)
    shift
    printf "\ndshUI is a library that proivdes various functions for generating a themeable UI for command line utilities.\n"
    exit 0
    ;;
  -t | --theme*)
    shift
    [[ -z "${1}" ]] && logMissingFlagArgumentErrorAndExit1 "name of the theme file" "--theme"
    [[ -x "$(determineThemeFilePath "$1")" ]] || logFileDoesNotExistErrorAndExit1 "$(determineThemeFilePath "${1}")"
    DSHUI_THEME="${1}"
    ;;
  -d | --demo-theme*)
    shift
    DEMO_THEME="show"
    ;;
  *)
    shift
    [[ "${1}" == "$(echo)" ]] && break # This is a bit of a hack to capture <enter>, the call to shift above will set $1 to <enter> if there are no more arguments/flags to parse, if $1 is <enter> then the loop MUST break since there are no more args/flags to parse. <enter> is captured using echo in a subshell. This hack was discovered @ https://stackoverflow.com/questions/6264596/simulating-enter-keypress-in-bash-script
    [[ -z "${1}" ]] && [[ "${DEMO_THEME}" != 'show' ]] && logInvalidFlagErrorAndExit1 "${1}"
    ;;
  esac
done

[[ -z "${DSHUI_THEME}" ]] && DSHUI_THEME='dshUIDefaultTheme.sh'
# Load specified theme, or default theme if specified theme does not exist or if a theme was not specified.
# @todo Implement --theme flag, and shorthand -t
loadLibrary "$(determineThemeFilePath "${DSHUI_THEME}")"
loadLibrary "$(determineCurrentDirectoryPath)/dshUIFunctions.sh" # MUST be loaded AFTER theme UNLESS you keep initTextStyles()

if [[ "${DEMO_THEME}" == 'show' ]]; then
    showLoadingBar "Loading demo of the ${DSHUI_THEME} theme's colors" 'dontClear'
    demoTheme | column
    exit 0
fi


